package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strings"
	"unicode"

	"github.com/chippydip/go-sc2ai/api"
	"github.com/chippydip/go-sc2ai/client"
	"github.com/chippydip/go-sc2ai/runner"
)

func main() {
	// TODO: remove this and make it use a random map
	runner.Set("map", "C:/Program Files (x86)/StarCraft II/Maps/InterloperLE.SC2Map")

	runner.RunAgent(client.NewParticipant(api.Race_Random, &myBot{}))
}

type myBot struct{}

func (myBot) OnGameStart(info client.AgentInfo) {
	dumpAbilities(info.Data().GetAbilities())
	dumpBuffs(info.Data().GetBuffs())
	dumpEffects(info.Data().GetEffects())
	dumpUnits(info.Data().GetUnits())
	dumpUpgrades(info.Data().GetUpgrades())
}

func (myBot) OnStep()    {}
func (myBot) OnGameEnd() {}

func dumpAbilities(abilities []*api.AbilityData) {
	// Detect base abilities of things with assigned hotkeys
	remaps := map[uint32]bool{}
	for _, ability := range abilities {
		if ability.GetAvailable() && ability.ButtonName != "" {
			if ability.RemapsToAbilityId != 0 && ability.Hotkey != "" {
				remaps[ability.RemapsToAbilityId] = true
			}
		}
	}

	// Find values to export and detect duplicate names
	byName := map[string]int{}
	for _, ability := range abilities {
		if ability.GetAvailable() && ability.ButtonName != "" {
			if ability.Hotkey != "" || remaps[ability.AbilityId] {
				byName[ability.FriendlyName] = byName[ability.FriendlyName] + 1
			}
		}
	}

	// Generate the values
	names := []string{}
	values := map[string]uint32{}
	for _, ability := range abilities {
		n := byName[ability.FriendlyName]
		if n == 0 {
			continue
		}

		if ability.GetAvailable() && ability.ButtonName != "" {
			if ability.Hotkey != "" || remaps[ability.AbilityId] {
				name := ability.FriendlyName
				if n > 1 {
					name = fmt.Sprintf("%v %v", name, ability.AbilityId)
				}
				name = makeID(name)

				names = append(names, name)
				values[name] = ability.AbilityId
			}
		}
	}
	sort.Strings(names)

	values["Invalid"] = 0
	values["Smart"] = 1
	writeEnum("ability", append([]string{"Invalid", "Smart"}, names...), values)
}

func dumpBuffs(buffs []*api.BuffData) {
	names := []string{}
	values := map[string]uint32{}
	for _, buff := range buffs {
		if name := makeID(buff.GetName()); name != "" {
			names = append(names, name)
			values[name] = buff.BuffId
		}
	}
	//sort.Strings(names)

	values["Invalid"] = 0
	writeEnum("buff", append([]string{"Invalid"}, names...), values)
}

func dumpEffects(effects []*api.EffectData) {
	names := []string{}
	values := map[string]uint32{}
	for _, effect := range effects {
		if name := makeID(effect.GetFriendlyName()); name != "" {
			names = append(names, name)
			values[name] = effect.EffectId
		}
	}
	//sort.Strings(names)

	values["Invalid"] = 0
	writeEnum("effect", append([]string{"Invalid"}, names...), values)
}

func dumpUnits(units []*api.UnitTypeData) {
	names := []string{}
	values := map[string]uint32{}
	for _, unit := range units {
		if unit.GetAvailable() && unit.Name != "" {
			race := unit.Race.String()
			if race == "NoRace" {
				race = "Neutral"
			}
			name := makeID(race + "_" + unit.Name)

			names = append(names, name)
			values[name] = unit.UnitId
		}
	}
	sort.Strings(names)

	values["Invalid"] = 0
	writeEnum("unit", append([]string{"Invalid"}, names...), values)
}

func dumpUpgrades(upgrades []*api.UpgradeData) {
	names := []string{}
	values := map[string]uint32{}
	for _, upgrade := range upgrades {
		if name := makeID(upgrade.GetName()); name != "" {
			names = append(names, name)
			values[name] = upgrade.UpgradeId
		}
	}
	//sort.Strings(names)

	values["Invalid"] = 0
	writeEnum("upgrade", append([]string{"Invalid"}, names...), values)
}

func makeID(id string) string {
	id = strings.Replace(id, " ", "_", -1)
	for _, c := range id {
		if !unicode.IsLetter(c) {
			return "A_" + id
		}
		break
	}
	return id
}

func writeEnum(name string, names []string, values map[string]uint32) {
	pkgName := strings.ToLower(name)
	typeName := strings.Title(pkgName)
	fmtString := "\t%-*v " + typeName + " = %v\n"

	maxLen := 0
	for _, name := range names {
		if len(name) > maxLen {
			maxLen = len(name)
		}
	}

	check(os.MkdirAll("api/"+pkgName, 0777))
	file, err := os.Create("api/" + pkgName + "/enum.go")
	check(err)
	defer file.Close()

	w := bufio.NewWriter(file)

	fmt.Fprint(w, "// Code generated by gen_ids. DO NOT EDIT.\npackage "+pkgName+"\n")
	fmt.Fprint(w, "\ntype "+typeName+" uint32\n\nconst (\n")
	for _, name := range names {
		fmt.Fprintf(w, fmtString, maxLen, name, values[name])
	}
	fmt.Fprint(w, ")\n")
	check(w.Flush())
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
